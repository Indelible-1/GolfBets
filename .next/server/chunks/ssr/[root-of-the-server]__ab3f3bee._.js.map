{"version":3,"sources":["../../../../src/hooks/useAuth.ts","../../../../src/lib/firestore/users.ts","../../../../src/lib/firestore/converters.ts","../../../../src/lib/firestore/collections.ts","../../../../src/components/auth/ProtectedRoute.tsx","../../../../src/lib/firestore/matches.ts","../../../../src/hooks/useMatch.ts","../../../../src/hooks/useLedger.ts","../../../../src/lib/ledger/balances.ts","../../../../src/app/match/%5Bid%5D/results/page.tsx","../../../../src/components/results/ResultsCard.tsx","../../../../src/lib/firestore/participants.ts"],"sourcesContent":["'use client'\n\nimport { useEffect, useState } from 'react'\nimport { onAuthStateChanged, User as FirebaseUser } from 'firebase/auth'\nimport { auth } from '@/lib/firebase'\nimport { User } from '@/types'\nimport { getUser, createUser, updateUserActivity } from '@/lib/firestore/users'\n\ninterface UseAuthReturn {\n  firebaseUser: FirebaseUser | null\n  user: User | null\n  loading: boolean\n  error: Error | null\n}\n\n/**\n * Hook to manage authentication state and Firestore user document\n * Automatically syncs Firebase Auth with Firestore user profile\n */\nexport function useAuth(): UseAuthReturn {\n  const [firebaseUser, setFirebaseUser] = useState<FirebaseUser | null>(null)\n  const [user, setUser] = useState<User | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (firebaseUserData) => {\n      try {\n        setFirebaseUser(firebaseUserData)\n\n        if (firebaseUserData) {\n          // User signed in\n          let userData = await getUser(firebaseUserData.uid)\n\n          if (!userData) {\n            // First sign-in: create user document\n            const displayName = firebaseUserData.displayName || firebaseUserData.email || 'User'\n            const email = firebaseUserData.email || ''\n\n            userData = await createUser(firebaseUserData.uid, {\n              displayName,\n              email,\n            })\n          } else {\n            // Update last active timestamp\n            await updateUserActivity(firebaseUserData.uid)\n          }\n\n          setUser(userData)\n          setError(null)\n        } else {\n          // User signed out\n          setUser(null)\n          setError(null)\n        }\n\n        setLoading(false)\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Unknown auth error')\n        setError(error)\n        setLoading(false)\n      }\n    })\n\n    return () => unsubscribe()\n  }, [])\n\n  return {\n    firebaseUser,\n    user,\n    loading,\n    error,\n  }\n}\n","import { getDoc, setDoc, updateDoc } from 'firebase/firestore'\nimport { User, TeeBox } from '@/types'\nimport { userDoc } from './collections'\n\n// ============ READ ============\n\n/**\n * Fetch user document by ID\n */\nexport async function getUser(userId: string): Promise<User | null> {\n  try {\n    const snapshot = await getDoc(userDoc(userId))\n    return snapshot.exists() ? snapshot.data() : null\n  } catch (error) {\n    console.error('Error fetching user:', error)\n    throw error\n  }\n}\n\n// ============ CREATE ============\n\n/**\n * Create new user document (called after first sign-in)\n */\nexport async function createUser(\n  userId: string,\n  data: {\n    displayName: string\n    email: string\n  },\n): Promise<User> {\n  const now = new Date()\n  const user: User = {\n    id: userId,\n    displayName: data.displayName,\n    email: data.email,\n    avatarUrl: null,\n\n    // Golf profile defaults\n    handicapIndex: null,\n    homeClub: null,\n    defaultTeeBox: 'blue' as TeeBox,\n\n    // Preferences defaults\n    notificationsEnabled: true,\n\n    // Metadata\n    createdAt: now,\n    updatedAt: now,\n    lastActiveAt: now,\n  }\n\n  try {\n    await setDoc(userDoc(userId), user)\n    return user\n  } catch (error) {\n    console.error('Error creating user:', error)\n    throw error\n  }\n}\n\n// ============ UPDATE ============\n\n/**\n * Update user profile fields (displayName, handicap, etc.)\n */\nexport async function updateUser(\n  userId: string,\n  updates: Partial<Omit<User, 'id' | 'email' | 'createdAt'>>,\n): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      ...updates,\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating user:', error)\n    throw error\n  }\n}\n\n/**\n * Update user's last active timestamp (for stale user cleanup)\n */\nexport async function updateUserActivity(userId: string): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      lastActiveAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating user activity:', error)\n    throw error\n  }\n}\n\n/**\n * Update user's golf preferences\n */\nexport async function updateUserGolfProfile(\n  userId: string,\n  profile: {\n    handicapIndex?: number | null\n    homeClub?: string | null\n    defaultTeeBox?: TeeBox\n  },\n): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      ...profile,\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating golf profile:', error)\n    throw error\n  }\n}\n\n/**\n * Update user notification preferences\n */\nexport async function updateNotificationPreferences(\n  userId: string,\n  notificationsEnabled: boolean,\n): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      notificationsEnabled,\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating notification preferences:', error)\n    throw error\n  }\n}\n","import {\n  Timestamp,\n  FirestoreDataConverter,\n  QueryDocumentSnapshot,\n} from 'firebase/firestore'\nimport {\n  User,\n  FirestoreUser,\n  Match,\n  FirestoreMatch,\n  Participant,\n  FirestoreParticipant,\n  Score,\n  FirestoreScore,\n  Bet,\n  FirestoreBet,\n  LedgerEntry,\n  FirestoreLedgerEntry,\n  AuditEntry,\n  FirestoreAuditEntry,\n  Invite,\n  FirestoreInvite,\n} from '@/types'\n\n// ============ TIMESTAMP HELPERS ============\n\nexport const toDate = (timestamp: Timestamp | null | undefined): Date | null => {\n  return timestamp ? timestamp.toDate() : null\n}\n\nexport const fromDate = (date: Date | null | undefined): Timestamp | null => {\n  return date ? Timestamp.fromDate(date) : null\n}\n\n// ============ USER CONVERTER ============\n\nexport const userConverter: FirestoreDataConverter<User> = {\n  toFirestore: (user: User): FirestoreUser => ({\n    ...user,\n    createdAt: Timestamp.fromDate(user.createdAt),\n    updatedAt: Timestamp.fromDate(user.updatedAt),\n    lastActiveAt: Timestamp.fromDate(user.lastActiveAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreUser>): User => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      updatedAt: data.updatedAt.toDate(),\n      lastActiveAt: data.lastActiveAt.toDate(),\n    }\n  },\n}\n\n// ============ MATCH CONVERTER ============\n\nexport const matchConverter: FirestoreDataConverter<Match> = {\n  toFirestore: (match: Match): FirestoreMatch => ({\n    ...match,\n    createdAt: Timestamp.fromDate(match.createdAt),\n    updatedAt: Timestamp.fromDate(match.updatedAt),\n    startedAt: match.startedAt ? Timestamp.fromDate(match.startedAt) : null,\n    completedAt: match.completedAt ? Timestamp.fromDate(match.completedAt) : null,\n    teeTime: Timestamp.fromDate(match.teeTime),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreMatch>): Match => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      updatedAt: data.updatedAt.toDate(),\n      startedAt: data.startedAt?.toDate() ?? null,\n      completedAt: data.completedAt?.toDate() ?? null,\n      teeTime: data.teeTime.toDate(),\n    }\n  },\n}\n\n// ============ PARTICIPANT CONVERTER ============\n\nexport const participantConverter: FirestoreDataConverter<Participant> = {\n  toFirestore: (participant: Participant): FirestoreParticipant => ({\n    ...participant,\n    invitedAt: Timestamp.fromDate(participant.invitedAt),\n    confirmedAt: participant.confirmedAt ? Timestamp.fromDate(participant.confirmedAt) : null,\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreParticipant>): Participant => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      invitedAt: data.invitedAt.toDate(),\n      confirmedAt: data.confirmedAt?.toDate() ?? null,\n    }\n  },\n}\n\n// ============ SCORE CONVERTER ============\n\nexport const scoreConverter: FirestoreDataConverter<Score> = {\n  toFirestore: (score: Score): FirestoreScore => ({\n    ...score,\n    createdAt: Timestamp.fromDate(score.createdAt),\n    updatedAt: Timestamp.fromDate(score.updatedAt),\n    syncedAt: score.syncedAt ? Timestamp.fromDate(score.syncedAt) : null,\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreScore>): Score => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      updatedAt: data.updatedAt.toDate(),\n      syncedAt: data.syncedAt?.toDate() ?? null,\n    }\n  },\n}\n\n// ============ BET CONVERTER ============\n\nexport const betConverter: FirestoreDataConverter<Bet> = {\n  toFirestore: (bet: Bet): FirestoreBet => ({\n    ...bet,\n    createdAt: Timestamp.fromDate(bet.createdAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreBet>): Bet => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n    }\n  },\n}\n\n// ============ LEDGER CONVERTER ============\n\nexport const ledgerConverter: FirestoreDataConverter<LedgerEntry> = {\n  toFirestore: (entry: LedgerEntry): FirestoreLedgerEntry => ({\n    ...entry,\n    createdAt: Timestamp.fromDate(entry.createdAt),\n    settledAt: entry.settledAt ? Timestamp.fromDate(entry.settledAt) : null,\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreLedgerEntry>): LedgerEntry => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      settledAt: data.settledAt?.toDate() ?? null,\n    }\n  },\n}\n\n// ============ AUDIT CONVERTER ============\n\nexport const auditConverter: FirestoreDataConverter<AuditEntry> = {\n  toFirestore: (entry: AuditEntry): FirestoreAuditEntry => ({\n    ...entry,\n    changedAt: Timestamp.fromDate(entry.changedAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreAuditEntry>): AuditEntry => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      changedAt: data.changedAt.toDate(),\n    }\n  },\n}\n\n// ============ INVITE CONVERTER ============\n\nexport const inviteConverter: FirestoreDataConverter<Invite> = {\n  toFirestore: (invite: Invite): FirestoreInvite => ({\n    ...invite,\n    createdAt: Timestamp.fromDate(invite.createdAt),\n    expiresAt: Timestamp.fromDate(invite.expiresAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreInvite>): Invite => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      expiresAt: data.expiresAt.toDate(),\n    }\n  },\n}\n","import {\n  collection,\n  CollectionReference,\n  DocumentReference,\n  doc,\n  getFirestore,\n  Firestore,\n} from 'firebase/firestore'\nimport {\n  User,\n  Match,\n  Participant,\n  Score,\n  Bet,\n  LedgerEntry,\n  AuditEntry,\n  Invite,\n} from '@/types'\nimport {\n  userConverter,\n  matchConverter,\n  participantConverter,\n  scoreConverter,\n  betConverter,\n  ledgerConverter,\n  auditConverter,\n  inviteConverter,\n} from './converters'\n\nlet db: Firestore | undefined\n\nfunction getDb(): Firestore {\n  if (!db) {\n    db = getFirestore()\n  }\n  return db\n}\n\n// ============ ROOT COLLECTIONS ============\n\nexport const usersCollection = (): CollectionReference<User> =>\n  collection(getDb(), 'users').withConverter(userConverter)\n\nexport const matchesCollection = (): CollectionReference<Match> =>\n  collection(getDb(), 'matches').withConverter(matchConverter)\n\nexport const invitesCollection = (): CollectionReference<Invite> =>\n  collection(getDb(), 'invites').withConverter(inviteConverter)\n\n// ============ SUBCOLLECTIONS ============\n\nexport const betsCollection = (matchId: string): CollectionReference<Bet> =>\n  collection(getDb(), `matches/${matchId}/bets`).withConverter(betConverter)\n\nexport const participantsCollection = (matchId: string): CollectionReference<Participant> =>\n  collection(getDb(), `matches/${matchId}/participants`).withConverter(participantConverter)\n\nexport const scoresCollection = (matchId: string): CollectionReference<Score> =>\n  collection(getDb(), `matches/${matchId}/scores`).withConverter(scoreConverter)\n\nexport const ledgerCollection = (matchId: string): CollectionReference<LedgerEntry> =>\n  collection(getDb(), `matches/${matchId}/ledger`).withConverter(ledgerConverter)\n\nexport const auditCollection = (matchId: string): CollectionReference<AuditEntry> =>\n  collection(getDb(), `matches/${matchId}/audit`).withConverter(auditConverter)\n\n// ============ DOCUMENT REFERENCES ============\n\nexport const userDoc = (userId: string): DocumentReference<User> =>\n  doc(collection(getDb(), 'users'), userId).withConverter(userConverter) as DocumentReference<User>\n\nexport const matchDoc = (matchId: string): DocumentReference<Match> =>\n  doc(collection(getDb(), 'matches'), matchId).withConverter(matchConverter) as DocumentReference<Match>\n\nexport const betDoc = (matchId: string, betId: string): DocumentReference<Bet> =>\n  doc(collection(getDb(), `matches/${matchId}/bets`), betId).withConverter(betConverter) as DocumentReference<Bet>\n\nexport const participantDoc = (\n  matchId: string,\n  participantId: string,\n): DocumentReference<Participant> =>\n  doc(\n    collection(getDb(), `matches/${matchId}/participants`),\n    participantId,\n  ).withConverter(participantConverter) as DocumentReference<Participant>\n\nexport const scoreDoc = (matchId: string, scoreId: string): DocumentReference<Score> =>\n  doc(collection(getDb(), `matches/${matchId}/scores`), scoreId).withConverter(\n    scoreConverter,\n  ) as DocumentReference<Score>\n\nexport const ledgerEntryDoc = (\n  matchId: string,\n  entryId: string,\n): DocumentReference<LedgerEntry> =>\n  doc(collection(getDb(), `matches/${matchId}/ledger`), entryId).withConverter(\n    ledgerConverter,\n  ) as DocumentReference<LedgerEntry>\n\nexport const auditEntryDoc = (\n  matchId: string,\n  auditId: string,\n): DocumentReference<AuditEntry> =>\n  doc(collection(getDb(), `matches/${matchId}/audit`), auditId).withConverter(\n    auditConverter,\n  ) as DocumentReference<AuditEntry>\n\nexport const inviteDoc = (inviteId: string): DocumentReference<Invite> =>\n  doc(collection(getDb(), 'invites'), inviteId).withConverter(\n    inviteConverter,\n  ) as DocumentReference<Invite>\n","'use client'\n\nimport { useEffect } from 'react'\nimport { useRouter } from 'next/navigation'\nimport { useAuth } from '@/hooks/useAuth'\nimport { Screen } from '@/components/layout'\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode\n}\n\nexport function ProtectedRoute({ children }: ProtectedRouteProps) {\n  const { user, loading } = useAuth()\n  const router = useRouter()\n\n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/login')\n    }\n  }, [user, loading, router])\n\n  if (loading) {\n    return (\n      <Screen className=\"flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin text-4xl mb-4\">â›³</div>\n          <p className=\"text-gray-500\">Loading...</p>\n        </div>\n      </Screen>\n    )\n  }\n\n  if (!user) {\n    return null\n  }\n\n  return <>{children}</>\n}\n","import { getDoc, setDoc, updateDoc, query, where, getDocs } from 'firebase/firestore'\nimport { Match, MatchStatus } from '@/types'\nimport { matchDoc, matchesCollection } from './collections'\n\n// ============ READ ============\n\n/**\n * Fetch match document by ID\n */\nexport async function getMatch(matchId: string): Promise<Match | null> {\n  try {\n    const snapshot = await getDoc(matchDoc(matchId))\n    return snapshot.exists() ? snapshot.data() : null\n  } catch (error) {\n    console.error('Error fetching match:', error)\n    throw error\n  }\n}\n\n/**\n * Get all matches for a user (filters by participantIds array)\n * @param userId The user ID to query\n * @param statusFilter Optional status filter (pending, active, completed)\n */\nexport async function getUserMatches(\n  userId: string,\n  statusFilter?: MatchStatus,\n): Promise<Match[]> {\n  try {\n    const q = query(\n      matchesCollection(),\n      where('participantIds', 'array-contains', userId),\n    )\n\n    const snapshot = await getDocs(q)\n    let matches = snapshot.docs.map((doc) => doc.data())\n\n    if (statusFilter) {\n      matches = matches.filter((m) => m.status === statusFilter)\n    }\n\n    // Sort by teeTime descending (most recent first)\n    return matches.sort((a, b) => b.teeTime.getTime() - a.teeTime.getTime())\n  } catch (error) {\n    console.error('Error fetching user matches:', error)\n    throw error\n  }\n}\n\n/**\n * Get all matches created by a user\n */\nexport async function getCreatedMatches(userId: string): Promise<Match[]> {\n  try {\n    const q = query(matchesCollection(), where('createdBy', '==', userId))\n    const snapshot = await getDocs(q)\n    const matches = snapshot.docs.map((doc) => doc.data())\n    return matches.sort((a, b) => b.teeTime.getTime() - a.teeTime.getTime())\n  } catch (error) {\n    console.error('Error fetching created matches:', error)\n    throw error\n  }\n}\n\n// ============ CREATE ============\n\n/**\n * Create new match (called by match creator)\n */\nexport async function createMatch(\n  userId: string,\n  data: {\n    courseName: string\n    teeTime: Date\n    courseId?: string\n    holes?: 9 | 18\n  },\n): Promise<Match> {\n  const now = new Date()\n  const matchId = `match_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n\n  const match: Match = {\n    id: matchId,\n    courseName: data.courseName,\n    courseId: data.courseId || null,\n    teeTime: data.teeTime,\n    holes: data.holes || 18,\n    status: 'pending' as MatchStatus,\n    currentHole: null,\n    createdBy: userId,\n    scorerId: userId,\n    participantIds: [userId],\n    createdAt: now,\n    updatedAt: now,\n    startedAt: null,\n    completedAt: null,\n    version: 1,\n  }\n\n  try {\n    await setDoc(matchDoc(matchId), match)\n    return match\n  } catch (error) {\n    console.error('Error creating match:', error)\n    throw error\n  }\n}\n\n// ============ UPDATE ============\n\n/**\n * Update match status (pending â†’ active â†’ completed)\n */\nexport async function updateMatchStatus(\n  matchId: string,\n  status: MatchStatus,\n): Promise<void> {\n  try {\n    const updates: Record<string, unknown> = {\n      status,\n      updatedAt: new Date(),\n    }\n\n    if (status === 'active') {\n      updates.startedAt = new Date()\n    } else if (status === 'completed') {\n      updates.completedAt = new Date()\n    }\n\n    await updateDoc(matchDoc(matchId), updates)\n  } catch (error) {\n    console.error('Error updating match status:', error)\n    throw error\n  }\n}\n\n/**\n * Add participant to match (updates participantIds array)\n */\nexport async function addParticipantToMatch(\n  matchId: string,\n  userId: string,\n): Promise<void> {\n  try {\n    const match = await getMatch(matchId)\n    if (!match) {\n      throw new Error('Match not found')\n    }\n\n    // Avoid duplicates\n    if (match.participantIds.includes(userId)) {\n      return\n    }\n\n    await updateDoc(matchDoc(matchId), {\n      participantIds: [...match.participantIds, userId],\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error adding participant to match:', error)\n    throw error\n  }\n}\n\n/**\n * Remove participant from match (only if pending status)\n */\nexport async function removeParticipantFromMatch(\n  matchId: string,\n  userId: string,\n): Promise<void> {\n  try {\n    const match = await getMatch(matchId)\n    if (!match) {\n      throw new Error('Match not found')\n    }\n\n    if (match.status !== 'pending') {\n      throw new Error('Cannot remove participants from active or completed matches')\n    }\n\n    await updateDoc(matchDoc(matchId), {\n      participantIds: match.participantIds.filter((id) => id !== userId),\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error removing participant from match:', error)\n    throw error\n  }\n}\n","'use client'\n\nimport { useEffect, useState } from 'react'\nimport { onSnapshot } from 'firebase/firestore'\nimport { Match, Participant } from '@/types'\nimport { matchDoc, participantsCollection } from '@/lib/firestore/collections'\nimport { getMatch } from '@/lib/firestore/matches'\n\ninterface UseMatchReturn {\n  match: Match | null\n  participants: Participant[]\n  loading: boolean\n  error: Error | null\n}\n\n/**\n * Hook to fetch match data with real-time updates\n * Automatically subscribes to match document and participants subcollection\n *\n * @param matchId Match ID to subscribe to\n * @returns Match, participants, loading state, and error\n */\nexport function useMatch(matchId: string | null): UseMatchReturn {\n  const [match, setMatch] = useState<Match | null>(null)\n  const [participants, setParticipants] = useState<Participant[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    if (!matchId) {\n      return\n    }\n\n    let unsubscribeMatch: (() => void) | null = null\n    let unsubscribeParticipants: (() => void) | null = null\n\n    const setupSubscriptions = async () => {\n      try {\n        // Initial fetch to ensure data exists\n        const matchData = await getMatch(matchId)\n        if (!matchData) {\n          setError(new Error('Match not found'))\n          setLoading(false)\n          return\n        }\n\n        // Subscribe to match document\n        unsubscribeMatch = onSnapshot(matchDoc(matchId), (snapshot) => {\n          if (snapshot.exists()) {\n            setMatch(snapshot.data())\n            setError(null)\n          } else {\n            setError(new Error('Match was deleted'))\n          }\n        })\n\n        // Subscribe to participants subcollection\n        unsubscribeParticipants = onSnapshot(\n          participantsCollection(matchId),\n          (snapshot) => {\n            const participantsData = snapshot.docs.map((doc) => doc.data())\n            setParticipants(participantsData)\n            setLoading(false)\n          },\n          (err) => {\n            console.error('Error subscribing to participants:', err)\n            setError(err instanceof Error ? err : new Error('Unknown error'))\n            setLoading(false)\n          },\n        )\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Unknown error')\n        setError(error)\n        setLoading(false)\n      }\n    }\n\n    setupSubscriptions()\n\n    return () => {\n      unsubscribeMatch?.()\n      unsubscribeParticipants?.()\n    }\n  }, [matchId])\n\n  return {\n    match,\n    participants,\n    loading,\n    error,\n  }\n}\n","'use client'\n\nimport { useEffect, useState } from 'react'\nimport { collectionGroup, onSnapshot, query, where, getFirestore } from 'firebase/firestore'\nimport { LedgerEntry } from '@/types'\nimport { calculateMatchBalances, calculateUnsettledBalances, getDebtors, getCreditors } from '@/lib/ledger/balances'\n\nconst db = getFirestore()\n\ninterface UseLedgerReturn {\n  entries: LedgerEntry[]\n  balances: Map<string, number>\n  unsettledBalances: Map<string, number>\n  debtors: Array<{ userId: string; amount: number }>\n  creditors: Array<{ userId: string; amount: number }>\n  loading: boolean\n  error: Error | null\n}\n\n/**\n * Hook to fetch user's ledger entries across all matches with real-time updates\n * Uses collectionGroup to query ledger subcollections\n *\n * @param userId User ID to fetch ledger for\n * @returns Ledger entries, balances, and loading state\n */\nexport function useLedger(userId: string | null): UseLedgerReturn {\n  const [entries, setEntries] = useState<LedgerEntry[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    if (!userId) {\n      return\n    }\n\n    let unsubscribeFrom: (() => void) | null = null\n    let unsubscribeTo: (() => void) | null = null\n\n    try {\n      // Query where user is the debtor (fromUserId)\n      const fromUserQuery = query(\n        collectionGroup(db, 'ledger'),\n        where('fromUserId', '==', userId),\n      )\n\n      // Query where user is the creditor (toUserId)\n      const toUserQuery = query(collectionGroup(db, 'ledger'), where('toUserId', '==', userId))\n\n      unsubscribeFrom = onSnapshot(\n        fromUserQuery,\n        (snapshot) => {\n          const fromEntries = snapshot.docs.map((doc) => doc.data() as LedgerEntry)\n          setEntries((prevEntries) => {\n            const toEntries = prevEntries.filter((entry) => entry.toUserId === userId)\n            return [...fromEntries, ...toEntries]\n          })\n          setError(null)\n          setLoading(false)\n        },\n        (err) => {\n          console.error('Error subscribing to ledger (from):', err)\n          setError(err instanceof Error ? err : new Error('Unknown error'))\n          setLoading(false)\n        },\n      )\n\n      unsubscribeTo = onSnapshot(\n        toUserQuery,\n        (snapshot) => {\n          const toEntries = snapshot.docs.map((doc) => doc.data() as LedgerEntry)\n          setEntries((prevEntries) => {\n            const fromEntries = prevEntries.filter((entry) => entry.fromUserId === userId)\n            return [...fromEntries, ...toEntries]\n          })\n          setError(null)\n          setLoading(false)\n        },\n        (err) => {\n          console.error('Error subscribing to ledger (to):', err)\n          setError(err instanceof Error ? err : new Error('Unknown error'))\n          setLoading(false)\n        },\n      )\n\n      return () => {\n        unsubscribeFrom?.()\n        unsubscribeTo?.()\n      }\n    } catch {\n      // Silently catch setup errors - error is already handled in onSnapshot error handler\n    }\n  }, [userId])\n\n  // Calculate derived values\n  const balances = calculateMatchBalances(entries)\n  const unsettledBalances = calculateUnsettledBalances(entries)\n  const debtors = getDebtors(balances)\n  const creditors = getCreditors(balances)\n\n  return {\n    entries,\n    balances,\n    unsettledBalances,\n    debtors,\n    creditors,\n    loading,\n    error,\n  }\n}\n\n/**\n * Hook to fetch ledger entries for a specific match with real-time updates\n *\n * @param matchId Match ID to fetch ledger for\n * @returns Match ledger entries with balances\n */\nexport function useMatchLedger(matchId: string | null) {\n  const [entries, setEntries] = useState<LedgerEntry[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    if (!matchId) {\n      return\n    }\n\n    try {\n      const unsubscribe = onSnapshot(\n        query(collectionGroup(db, 'ledger')),\n        (snapshot) => {\n          // Filter to only this match (match path is in documentRef)\n          const matchEntries = snapshot.docs\n            .filter((doc) => doc.ref.parent.parent?.id === matchId)\n            .map((doc) => doc.data() as LedgerEntry)\n          setEntries(matchEntries)\n          setError(null)\n          setLoading(false)\n        },\n        (err) => {\n          console.error('Error subscribing to match ledger:', err)\n          setError(err instanceof Error ? err : new Error('Unknown error'))\n          setLoading(false)\n        },\n      )\n\n      return () => unsubscribe()\n    } catch {\n      // Silently catch setup errors - error is already handled in onSnapshot error handler\n    }\n  }, [matchId])\n\n  const balances = calculateMatchBalances(entries)\n  const unsettledBalances = calculateUnsettledBalances(entries)\n  const debtors = getDebtors(balances)\n  const creditors = getCreditors(balances)\n\n  return {\n    entries,\n    balances,\n    unsettledBalances,\n    debtors,\n    creditors,\n    loading,\n    error,\n  }\n}\n","import { LedgerEntry } from '@/types'\n\n/**\n * Balance for a single user in a transaction\n */\nexport interface UserBalance {\n  userId: string\n  amount: number // Positive = owed money, negative = owes money\n}\n\n/**\n * Net balance between two specific users (who owes whom)\n */\nexport interface PairwiseBalance {\n  userId: string\n  otherUserId: string\n  amount: number // Positive = userId owes otherUserId, negative = otherUserId owes userId\n}\n\n/**\n * Calculate the net balance for a user across ledger entries\n * Positive = user is owed money, negative = user owes money\n * @param userId User to calculate balance for\n * @param entries Ledger entries to include\n * @returns Net balance amount\n */\nexport function calculateUserBalance(userId: string, entries: LedgerEntry[]): number {\n  return entries.reduce((balance, entry) => {\n    // If user is receiving money (toUserId)\n    if (entry.toUserId === userId) {\n      return balance + entry.amount\n    }\n    // If user is paying money (fromUserId)\n    if (entry.fromUserId === userId) {\n      return balance - entry.amount\n    }\n    return balance\n  }, 0)\n}\n\n/**\n * Calculate balances for all participants in a match\n * Returns who owes whom and how much\n * @param entries Ledger entries for the match\n * @returns Map of userId -> net balance\n */\nexport function calculateMatchBalances(\n  entries: LedgerEntry[],\n): Map<string, number> {\n  const balances = new Map<string, number>()\n\n  // Initialize all users with 0 balance\n  entries.forEach((entry) => {\n    if (!balances.has(entry.fromUserId)) balances.set(entry.fromUserId, 0)\n    if (!balances.has(entry.toUserId)) balances.set(entry.toUserId, 0)\n  })\n\n  // Calculate balances\n  entries.forEach((entry) => {\n    const fromBalance = balances.get(entry.fromUserId) || 0\n    const toBalance = balances.get(entry.toUserId) || 0\n\n    balances.set(entry.fromUserId, fromBalance - entry.amount)\n    balances.set(entry.toUserId, toBalance + entry.amount)\n  })\n\n  return balances\n}\n\n/**\n * Get unsettled balance for all users in a match\n * Only includes entries where settled === false\n * @param entries Ledger entries for the match\n * @returns Map of userId -> unsettled balance\n */\nexport function calculateUnsettledBalances(\n  entries: LedgerEntry[],\n): Map<string, number> {\n  const unsettledEntries = entries.filter((entry) => !entry.settled)\n  return calculateMatchBalances(unsettledEntries)\n}\n\n/**\n * Calculate who owes money (debtors) in a match\n * Returns users with negative balance and how much they owe\n * @param balances Balance map from calculateMatchBalances()\n * @returns Array of { userId, amount owed }\n */\nexport function getDebtors(balances: Map<string, number>): UserBalance[] {\n  return Array.from(balances.entries())\n    .filter(([, amount]) => amount < 0)\n    .map(([userId, amount]) => ({\n      userId,\n      amount: Math.abs(amount),\n    }))\n    .sort((a, b) => b.amount - a.amount) // Sort descending by amount\n}\n\n/**\n * Calculate who is owed money (creditors) in a match\n * Returns users with positive balance and how much they're owed\n * @param balances Balance map from calculateMatchBalances()\n * @returns Array of { userId, amount owed }\n */\nexport function getCreditors(balances: Map<string, number>): UserBalance[] {\n  return Array.from(balances.entries())\n    .filter(([, amount]) => amount > 0)\n    .map(([userId, amount]) => ({\n      userId,\n      amount,\n    }))\n    .sort((a, b) => b.amount - a.amount) // Sort descending by amount\n}\n\n/**\n * Calculate net balance between two specific users\n * Positive = first user owes second user\n * Negative = second user owes first user\n * @param userId1 First user ID\n * @param userId2 Second user ID\n * @param entries Ledger entries to consider\n * @returns Net amount between users\n */\nexport function calculatePairwiseBalance(\n  userId1: string,\n  userId2: string,\n  entries: LedgerEntry[],\n): number {\n  const relevantEntries = entries.filter(\n    (entry) =>\n      (entry.fromUserId === userId1 && entry.toUserId === userId2) ||\n      (entry.fromUserId === userId2 && entry.toUserId === userId1),\n  )\n\n  let balance = 0\n  relevantEntries.forEach((entry) => {\n    if (entry.fromUserId === userId1 && entry.toUserId === userId2) {\n      balance += entry.amount // userId1 owes userId2\n    } else {\n      balance -= entry.amount // userId2 owes userId1\n    }\n  })\n\n  return balance\n}\n\n/**\n * Get all pairwise balances for unsettled entries in a match\n * Useful for settlement UI to show who owes whom\n * @param entries Ledger entries for the match\n * @returns Array of unique pairwise balances\n */\nexport function getPairwiseBalances(entries: LedgerEntry[]): PairwiseBalance[] {\n  const unsettledEntries = entries.filter((entry) => !entry.settled)\n  const pairwises = new Map<string, number>()\n\n  // Create a key for each unique pair\n  unsettledEntries.forEach((entry) => {\n    const key = [entry.fromUserId, entry.toUserId].sort().join('|')\n    const existing = pairwises.get(key) || 0\n\n    if (entry.fromUserId < entry.toUserId) {\n      pairwises.set(key, existing + entry.amount)\n    } else {\n      pairwises.set(key, existing - entry.amount)\n    }\n  })\n\n  // Convert to PairwiseBalance array\n  return Array.from(pairwises.entries())\n    .map(([key, amount]) => {\n      const [userId1, userId2] = key.split('|')\n      return {\n        userId: userId1,\n        otherUserId: userId2,\n        amount,\n      }\n    })\n    .filter((pair) => pair.amount !== 0) // Exclude settled pairs\n    .sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount)) // Sort by magnitude\n}\n\n/**\n * Check if a user has any unsettled debts in a match\n * @param userId User to check\n * @param entries Ledger entries for the match\n * @returns true if user owes money, false otherwise\n */\nexport function userHasUnsettledDebts(userId: string, entries: LedgerEntry[]): boolean {\n  const unsettledEntries = entries.filter((entry) => !entry.settled)\n  const balance = calculateUserBalance(userId, unsettledEntries)\n  return balance < 0\n}\n","'use client'\n\nimport { useEffect, useState } from 'react'\nimport Link from 'next/link'\nimport { Screen, Header } from '@/components/layout'\nimport { Button, Card } from '@/components/ui'\nimport { ResultsCard } from '@/components/results'\nimport { ProtectedRoute } from '@/components/auth'\nimport { useAuth } from '@/hooks/useAuth'\nimport { useMatch } from '@/hooks/useMatch'\nimport { useMatchLedger } from '@/hooks/useLedger'\nimport { getMatchParticipants } from '@/lib/firestore/participants'\nimport { getUser } from '@/lib/firestore/users'\nimport type { Participant, User } from '@/types'\n\ninterface ResultsPageProps {\n  params: { id: string }\n}\n\nexport default function ResultsPage({ params }: ResultsPageProps) {\n  const matchId = params.id\n  const { user } = useAuth()\n  const { match, loading: matchLoading } = useMatch(matchId)\n  const { entries: ledgerEntries, loading: ledgerLoading } = useMatchLedger(matchId)\n\n  const [participants, setParticipants] = useState<Participant[]>([])\n  const [participantUsers, setParticipantUsers] = useState<Map<string, User>>(new Map())\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  // Fetch participants and their user details\n  useEffect(() => {\n    if (!match) return\n\n    const fetchParticipantData = async () => {\n      try {\n        setLoading(true)\n        const parts = await getMatchParticipants(matchId)\n        setParticipants(parts)\n\n        // Fetch user details for each participant\n        const userMap = new Map<string, User>()\n        const userPromises = parts.map(async (part) => {\n          const userData = await getUser(part.userId)\n          if (userData) {\n            userMap.set(part.userId, userData)\n          }\n        })\n\n        await Promise.all(userPromises)\n        setParticipantUsers(userMap)\n        setError(null)\n      } catch (err) {\n        console.error('Error fetching participants:', err)\n        setError(err instanceof Error ? err.message : 'Failed to load match data')\n      } finally {\n        setLoading(false)\n      }\n    }\n\n    fetchParticipantData()\n  }, [match, matchId])\n\n  const isLoading = matchLoading || ledgerLoading || loading\n\n  if (isLoading) {\n    return (\n      <ProtectedRoute>\n        <Screen>\n          <Header title=\"Results\" />\n          <div className=\"p-4 flex items-center justify-center h-96\">\n            <div className=\"text-center space-y-2\">\n              <div className=\"animate-spin text-4xl\">â›³</div>\n              <p className=\"text-gray-500\">Loading results...</p>\n            </div>\n          </div>\n        </Screen>\n      </ProtectedRoute>\n    )\n  }\n\n  if (!match || !user) {\n    return (\n      <ProtectedRoute>\n        <Screen>\n          <Header title=\"Results\" />\n          <div className=\"p-4\">\n            <Card variant=\"outlined\" className=\"bg-red-50 border-red-200\">\n              <p className=\"text-red-700 text-sm\">Match not found or not authenticated</p>\n            </Card>\n          </div>\n        </Screen>\n      </ProtectedRoute>\n    )\n  }\n\n  // Build participant names map\n  const participantNames: Record<string, string> = {}\n  participants.forEach((part) => {\n    const partUser = participantUsers.get(part.userId)\n    participantNames[part.userId] = partUser?.displayName || `Player ${part.userId.slice(0, 6)}`\n  })\n\n  // Get unsettled settlements\n  const unsettledLedger = ledgerEntries.filter((entry) => !entry.settled)\n\n  return (\n    <ProtectedRoute>\n      <Screen padBottom>\n        <Header title={match.courseName} subtitle=\"Match Results\" />\n\n        <div className=\"p-4 pb-24 space-y-6\">\n          {error && (\n            <Card variant=\"outlined\" className=\"bg-red-50 border-red-200 p-4\">\n              <p className=\"text-red-700 text-sm\">{error}</p>\n            </Card>\n          )}\n\n          {/* Results Card */}\n          <ResultsCard\n            courseName={match.courseName}\n            date={match.teeTime}\n            holes={match.holes}\n            settlements={ledgerEntries}\n            participantNames={participantNames}\n          />\n\n          {/* Summary Stats */}\n          <div className=\"grid grid-cols-2 gap-3\">\n            <Card variant=\"elevated\" className=\"p-4 text-center\">\n              <p className=\"text-gray-500 text-sm mb-1\">Total Bets</p>\n              <p className=\"text-2xl font-bold text-fairway-600\">{ledgerEntries.length}</p>\n            </Card>\n\n            <Card variant=\"elevated\" className=\"p-4 text-center\">\n              <p className=\"text-gray-500 text-sm mb-1\">Unsettled</p>\n              <p className=\"text-2xl font-bold text-orange-600\">{unsettledLedger.length}</p>\n            </Card>\n          </div>\n\n          {/* Action Buttons */}\n          <div className=\"space-y-3\">\n            <Link href={`/match/${matchId}`} className=\"block\">\n              <Button variant=\"secondary\" fullWidth>\n                View Match Details\n              </Button>\n            </Link>\n\n            <Link href=\"/ledger\" className=\"block\">\n              <Button fullWidth>\n                View Full Ledger\n              </Button>\n            </Link>\n          </div>\n        </div>\n      </Screen>\n    </ProtectedRoute>\n  )\n}\n","'use client'\n\nimport { LedgerEntry } from '@/types'\nimport { Card, CardContent } from '@/components/ui'\nimport { cn } from '@/lib/utils'\n\ninterface ResultsCardProps {\n  courseName: string\n  date: Date\n  holes: 9 | 18\n  settlements: LedgerEntry[]\n  participantNames: Record<string, string>\n  className?: string\n}\n\nexport function ResultsCard({\n  courseName,\n  date,\n  holes,\n  settlements,\n  participantNames,\n  className,\n}: ResultsCardProps) {\n  const handleShare = async () => {\n    const shareText = `GolfSettled: ${courseName} - ${holes} holes - ${date.toLocaleDateString()}`\n    const shareUrl = typeof window !== 'undefined' ? window.location.href : ''\n\n    if (navigator.share) {\n      try {\n        await navigator.share({\n          title: 'GolfSettled Match Results',\n          text: shareText,\n          url: shareUrl,\n        })\n      } catch (err) {\n        if (err instanceof Error && err.name !== 'AbortError') {\n          console.error('Error sharing:', err)\n        }\n      }\n    } else {\n      // Fallback: copy to clipboard\n      const fullText = `${shareText}\\n${shareUrl}`\n      try {\n        await navigator.clipboard.writeText(fullText)\n        alert('Results link copied to clipboard!')\n      } catch (err) {\n        console.error('Error copying to clipboard:', err)\n      }\n    }\n  }\n\n  const unsettledCount = settlements.filter((s) => !s.settled).length\n\n  return (\n    <Card className={cn('overflow-hidden', className)}>\n      {/* Header with gradient */}\n      <div className=\"bg-gradient-to-r from-fairway-600 to-fairway-700 p-6 text-white\">\n        <h2 className=\"text-2xl font-bold mb-1\">{courseName}</h2>\n        <p className=\"text-fairway-100 text-sm mb-4\">\n          {date.toLocaleDateString('en-US', {\n            weekday: 'short',\n            month: 'short',\n            day: 'numeric',\n            year: 'numeric',\n          })}\n          {' â€¢ '}\n          {holes} holes\n        </p>\n\n        {/* Share Button */}\n        <button\n          onClick={handleShare}\n          className=\"inline-flex items-center gap-2 px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg text-white text-sm font-medium transition-colors\"\n          aria-label=\"Share results\"\n        >\n          <span>ðŸ“¤</span>\n          Share\n        </button>\n      </div>\n\n      {/* Settlements */}\n      <CardContent className=\"pt-6\">\n        {settlements.length === 0 ? (\n          <div className=\"text-center py-8\">\n            <p className=\"text-gray-500 text-sm\">No bets to settle</p>\n          </div>\n        ) : (\n          <div className=\"space-y-3\">\n            <h3 className=\"text-sm font-semibold text-gray-900 mb-4\">Settlements</h3>\n\n            {settlements.map((settlement) => {\n              const fromName = participantNames[settlement.fromUserId] || `Player ${settlement.fromUserId.slice(0, 6)}`\n              const toName = participantNames[settlement.toUserId] || `Player ${settlement.toUserId.slice(0, 6)}`\n\n              return (\n                <div\n                  key={settlement.id}\n                  className=\"flex items-center justify-between p-3 bg-gray-50 rounded-lg\"\n                >\n                  <div className=\"flex-1 text-sm\">\n                    <p className=\"text-gray-900 font-medium\">\n                      {fromName} â†’ {toName}\n                    </p>\n                    <p className=\"text-gray-500 text-xs mt-1\">\n                      {settlement.betType === 'nassau' ? 'Nassau' : settlement.betType === 'skins' ? 'Skins' : 'Bet'}\n                      {settlement.settled && ' â€¢ Settled'}\n                    </p>\n                  </div>\n\n                  <div className=\"text-right\">\n                    <p className={cn('font-bold text-lg', settlement.settled ? 'text-gray-400' : 'text-fairway-600')}>\n                      ${settlement.amount.toFixed(2)}\n                    </p>\n                  </div>\n                </div>\n              )\n            })}\n\n            {unsettledCount > 0 && (\n              <div className=\"mt-4 pt-4 border-t border-gray-200\">\n                <p className=\"text-xs text-gray-500 italic\">\n                  ðŸ’¡ Settle up offline via Venmo, Zelle, or cash. Mark as settled in the ledger when done.\n                </p>\n              </div>\n            )}\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  )\n}\n","import { getDoc, setDoc, updateDoc, getDocs } from 'firebase/firestore'\nimport { Participant, ParticipantStatus } from '@/types'\nimport { participantDoc, participantsCollection } from './collections'\n\n// ============ READ ============\n\n/**\n * Fetch participant document by ID\n */\nexport async function getParticipant(\n  matchId: string,\n  participantId: string,\n): Promise<Participant | null> {\n  try {\n    const snapshot = await getDoc(participantDoc(matchId, participantId))\n    return snapshot.exists() ? snapshot.data() : null\n  } catch (error) {\n    console.error('Error fetching participant:', error)\n    throw error\n  }\n}\n\n/**\n * Get all participants in a match\n */\nexport async function getMatchParticipants(matchId: string): Promise<Participant[]> {\n  try {\n    const snapshot = await getDocs(participantsCollection(matchId))\n    return snapshot.docs.map((doc) => doc.data())\n  } catch (error) {\n    console.error('Error fetching match participants:', error)\n    throw error\n  }\n}\n\n/**\n * Get participants in a match by status\n */\nexport async function getParticipantsByStatus(\n  matchId: string,\n  status: ParticipantStatus,\n): Promise<Participant[]> {\n  try {\n    const participants = await getMatchParticipants(matchId)\n    return participants.filter((p) => p.status === status)\n  } catch (error) {\n    console.error('Error fetching participants by status:', error)\n    throw error\n  }\n}\n\n// ============ CREATE ============\n\n/**\n * Create participant record (called when inviting/adding user to match)\n * @param matchId Match ID\n * @param userId User ID of the participant\n * @param data Optional handicap info\n */\nexport async function createParticipant(\n  matchId: string,\n  userId: string,\n  data?: {\n    displayName?: string\n    courseHandicap?: number\n  },\n): Promise<Participant> {\n  const now = new Date()\n  const participant: Participant = {\n    id: userId,\n    userId,\n    displayName: data?.displayName || 'Player',\n    playingHandicap: null,\n    teeBox: 'blue',\n    courseHandicap: data?.courseHandicap || null,\n    team: null,\n    status: 'invited' as ParticipantStatus,\n    invitedAt: now,\n    confirmedAt: null,\n  }\n\n  try {\n    await setDoc(participantDoc(matchId, userId), participant)\n    return participant\n  } catch (error) {\n    console.error('Error creating participant:', error)\n    throw error\n  }\n}\n\n// ============ UPDATE ============\n\n/**\n * Update participant status (invited â†’ confirmed â†’ completed)\n */\nexport async function updateParticipantStatus(\n  matchId: string,\n  participantId: string,\n  status: ParticipantStatus,\n): Promise<void> {\n  try {\n    const updates: Record<string, unknown> = {\n      status,\n    }\n\n    if (status === 'confirmed') {\n      updates.confirmedAt = new Date()\n    }\n\n    await updateDoc(participantDoc(matchId, participantId), updates)\n  } catch (error) {\n    console.error('Error updating participant status:', error)\n    throw error\n  }\n}\n\n/**\n * Update participant's handicap and tee box\n */\nexport async function updateParticipantHandicap(\n  matchId: string,\n  participantId: string,\n  handicapData: {\n    handicapIndex?: number\n    playingHandicap?: number\n    teeBox?: string\n  },\n): Promise<void> {\n  try {\n    await updateDoc(participantDoc(matchId, participantId), handicapData)\n  } catch (error) {\n    console.error('Error updating participant handicap:', error)\n    throw error\n  }\n}\n\n/**\n * Update participant display name\n */\nexport async function updateParticipantDisplayName(\n  matchId: string,\n  participantId: string,\n  displayName: string,\n): Promise<void> {\n  try {\n    await updateDoc(participantDoc(matchId, participantId), { displayName })\n  } catch (error) {\n    console.error('Error updating participant display name:', error)\n    throw error\n  }\n}\n"],"names":[],"mappings":"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"}
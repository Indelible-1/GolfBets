{"version":3,"sources":["../../../../src/hooks/useAuth.ts","../../../../src/lib/firestore/users.ts","../../../../src/lib/firestore/converters.ts","../../../../src/lib/firestore/collections.ts","../../../../src/components/auth/ProtectedRoute.tsx","../../../../src/lib/firestore/matches.ts","../../../../src/hooks/useMatch.ts"],"sourcesContent":["'use client'\n\nimport { useEffect, useState } from 'react'\nimport { onAuthStateChanged, User as FirebaseUser } from 'firebase/auth'\nimport { auth } from '@/lib/firebase'\nimport { User } from '@/types'\nimport { getUser, createUser, updateUserActivity } from '@/lib/firestore/users'\n\ninterface UseAuthReturn {\n  firebaseUser: FirebaseUser | null\n  user: User | null\n  loading: boolean\n  error: Error | null\n}\n\n/**\n * Hook to manage authentication state and Firestore user document\n * Automatically syncs Firebase Auth with Firestore user profile\n */\nexport function useAuth(): UseAuthReturn {\n  const [firebaseUser, setFirebaseUser] = useState<FirebaseUser | null>(null)\n  const [user, setUser] = useState<User | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, async (firebaseUserData) => {\n      try {\n        setFirebaseUser(firebaseUserData)\n\n        if (firebaseUserData) {\n          // User signed in\n          let userData = await getUser(firebaseUserData.uid)\n\n          if (!userData) {\n            // First sign-in: create user document\n            const displayName = firebaseUserData.displayName || firebaseUserData.email || 'User'\n            const email = firebaseUserData.email || ''\n\n            userData = await createUser(firebaseUserData.uid, {\n              displayName,\n              email,\n            })\n          } else {\n            // Update last active timestamp\n            await updateUserActivity(firebaseUserData.uid)\n          }\n\n          setUser(userData)\n          setError(null)\n        } else {\n          // User signed out\n          setUser(null)\n          setError(null)\n        }\n\n        setLoading(false)\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Unknown auth error')\n        setError(error)\n        setLoading(false)\n      }\n    })\n\n    return () => unsubscribe()\n  }, [])\n\n  return {\n    firebaseUser,\n    user,\n    loading,\n    error,\n  }\n}\n","import { getDoc, setDoc, updateDoc } from 'firebase/firestore'\nimport { User, TeeBox } from '@/types'\nimport { userDoc } from './collections'\n\n// ============ READ ============\n\n/**\n * Fetch user document by ID\n */\nexport async function getUser(userId: string): Promise<User | null> {\n  try {\n    const snapshot = await getDoc(userDoc(userId))\n    return snapshot.exists() ? snapshot.data() : null\n  } catch (error) {\n    console.error('Error fetching user:', error)\n    throw error\n  }\n}\n\n// ============ CREATE ============\n\n/**\n * Create new user document (called after first sign-in)\n */\nexport async function createUser(\n  userId: string,\n  data: {\n    displayName: string\n    email: string\n  },\n): Promise<User> {\n  const now = new Date()\n  const user: User = {\n    id: userId,\n    displayName: data.displayName,\n    email: data.email,\n    avatarUrl: null,\n\n    // Golf profile defaults\n    handicapIndex: null,\n    homeClub: null,\n    defaultTeeBox: 'blue' as TeeBox,\n\n    // Preferences defaults\n    notificationsEnabled: true,\n\n    // Metadata\n    createdAt: now,\n    updatedAt: now,\n    lastActiveAt: now,\n  }\n\n  try {\n    await setDoc(userDoc(userId), user)\n    return user\n  } catch (error) {\n    console.error('Error creating user:', error)\n    throw error\n  }\n}\n\n// ============ UPDATE ============\n\n/**\n * Update user profile fields (displayName, handicap, etc.)\n */\nexport async function updateUser(\n  userId: string,\n  updates: Partial<Omit<User, 'id' | 'email' | 'createdAt'>>,\n): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      ...updates,\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating user:', error)\n    throw error\n  }\n}\n\n/**\n * Update user's last active timestamp (for stale user cleanup)\n */\nexport async function updateUserActivity(userId: string): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      lastActiveAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating user activity:', error)\n    throw error\n  }\n}\n\n/**\n * Update user's golf preferences\n */\nexport async function updateUserGolfProfile(\n  userId: string,\n  profile: {\n    handicapIndex?: number | null\n    homeClub?: string | null\n    defaultTeeBox?: TeeBox\n  },\n): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      ...profile,\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating golf profile:', error)\n    throw error\n  }\n}\n\n/**\n * Update user notification preferences\n */\nexport async function updateNotificationPreferences(\n  userId: string,\n  notificationsEnabled: boolean,\n): Promise<void> {\n  try {\n    await updateDoc(userDoc(userId), {\n      notificationsEnabled,\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error updating notification preferences:', error)\n    throw error\n  }\n}\n","import {\n  Timestamp,\n  FirestoreDataConverter,\n  QueryDocumentSnapshot,\n} from 'firebase/firestore'\nimport {\n  User,\n  FirestoreUser,\n  Match,\n  FirestoreMatch,\n  Participant,\n  FirestoreParticipant,\n  Score,\n  FirestoreScore,\n  Bet,\n  FirestoreBet,\n  LedgerEntry,\n  FirestoreLedgerEntry,\n  AuditEntry,\n  FirestoreAuditEntry,\n  Invite,\n  FirestoreInvite,\n} from '@/types'\n\n// ============ TIMESTAMP HELPERS ============\n\nexport const toDate = (timestamp: Timestamp | null | undefined): Date | null => {\n  return timestamp ? timestamp.toDate() : null\n}\n\nexport const fromDate = (date: Date | null | undefined): Timestamp | null => {\n  return date ? Timestamp.fromDate(date) : null\n}\n\n// ============ USER CONVERTER ============\n\nexport const userConverter: FirestoreDataConverter<User> = {\n  toFirestore: (user: User): FirestoreUser => ({\n    ...user,\n    createdAt: Timestamp.fromDate(user.createdAt),\n    updatedAt: Timestamp.fromDate(user.updatedAt),\n    lastActiveAt: Timestamp.fromDate(user.lastActiveAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreUser>): User => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      updatedAt: data.updatedAt.toDate(),\n      lastActiveAt: data.lastActiveAt.toDate(),\n    }\n  },\n}\n\n// ============ MATCH CONVERTER ============\n\nexport const matchConverter: FirestoreDataConverter<Match> = {\n  toFirestore: (match: Match): FirestoreMatch => ({\n    ...match,\n    createdAt: Timestamp.fromDate(match.createdAt),\n    updatedAt: Timestamp.fromDate(match.updatedAt),\n    startedAt: match.startedAt ? Timestamp.fromDate(match.startedAt) : null,\n    completedAt: match.completedAt ? Timestamp.fromDate(match.completedAt) : null,\n    teeTime: Timestamp.fromDate(match.teeTime),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreMatch>): Match => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      updatedAt: data.updatedAt.toDate(),\n      startedAt: data.startedAt?.toDate() ?? null,\n      completedAt: data.completedAt?.toDate() ?? null,\n      teeTime: data.teeTime.toDate(),\n    }\n  },\n}\n\n// ============ PARTICIPANT CONVERTER ============\n\nexport const participantConverter: FirestoreDataConverter<Participant> = {\n  toFirestore: (participant: Participant): FirestoreParticipant => ({\n    ...participant,\n    invitedAt: Timestamp.fromDate(participant.invitedAt),\n    confirmedAt: participant.confirmedAt ? Timestamp.fromDate(participant.confirmedAt) : null,\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreParticipant>): Participant => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      invitedAt: data.invitedAt.toDate(),\n      confirmedAt: data.confirmedAt?.toDate() ?? null,\n    }\n  },\n}\n\n// ============ SCORE CONVERTER ============\n\nexport const scoreConverter: FirestoreDataConverter<Score> = {\n  toFirestore: (score: Score): FirestoreScore => ({\n    ...score,\n    createdAt: Timestamp.fromDate(score.createdAt),\n    updatedAt: Timestamp.fromDate(score.updatedAt),\n    syncedAt: score.syncedAt ? Timestamp.fromDate(score.syncedAt) : null,\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreScore>): Score => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      updatedAt: data.updatedAt.toDate(),\n      syncedAt: data.syncedAt?.toDate() ?? null,\n    }\n  },\n}\n\n// ============ BET CONVERTER ============\n\nexport const betConverter: FirestoreDataConverter<Bet> = {\n  toFirestore: (bet: Bet): FirestoreBet => ({\n    ...bet,\n    createdAt: Timestamp.fromDate(bet.createdAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreBet>): Bet => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n    }\n  },\n}\n\n// ============ LEDGER CONVERTER ============\n\nexport const ledgerConverter: FirestoreDataConverter<LedgerEntry> = {\n  toFirestore: (entry: LedgerEntry): FirestoreLedgerEntry => ({\n    ...entry,\n    createdAt: Timestamp.fromDate(entry.createdAt),\n    settledAt: entry.settledAt ? Timestamp.fromDate(entry.settledAt) : null,\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreLedgerEntry>): LedgerEntry => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      settledAt: data.settledAt?.toDate() ?? null,\n    }\n  },\n}\n\n// ============ AUDIT CONVERTER ============\n\nexport const auditConverter: FirestoreDataConverter<AuditEntry> = {\n  toFirestore: (entry: AuditEntry): FirestoreAuditEntry => ({\n    ...entry,\n    changedAt: Timestamp.fromDate(entry.changedAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreAuditEntry>): AuditEntry => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      changedAt: data.changedAt.toDate(),\n    }\n  },\n}\n\n// ============ INVITE CONVERTER ============\n\nexport const inviteConverter: FirestoreDataConverter<Invite> = {\n  toFirestore: (invite: Invite): FirestoreInvite => ({\n    ...invite,\n    createdAt: Timestamp.fromDate(invite.createdAt),\n    expiresAt: Timestamp.fromDate(invite.expiresAt),\n  }),\n  fromFirestore: (snapshot: QueryDocumentSnapshot<FirestoreInvite>): Invite => {\n    const data = snapshot.data()\n    return {\n      ...data,\n      id: snapshot.id,\n      createdAt: data.createdAt.toDate(),\n      expiresAt: data.expiresAt.toDate(),\n    }\n  },\n}\n","import {\n  collection,\n  CollectionReference,\n  DocumentReference,\n  doc,\n  getFirestore,\n  Firestore,\n} from 'firebase/firestore'\nimport {\n  User,\n  Match,\n  Participant,\n  Score,\n  Bet,\n  LedgerEntry,\n  AuditEntry,\n  Invite,\n} from '@/types'\nimport {\n  userConverter,\n  matchConverter,\n  participantConverter,\n  scoreConverter,\n  betConverter,\n  ledgerConverter,\n  auditConverter,\n  inviteConverter,\n} from './converters'\n\nlet db: Firestore | undefined\n\nfunction getDb(): Firestore {\n  if (!db) {\n    db = getFirestore()\n  }\n  return db\n}\n\n// ============ ROOT COLLECTIONS ============\n\nexport const usersCollection = (): CollectionReference<User> =>\n  collection(getDb(), 'users').withConverter(userConverter)\n\nexport const matchesCollection = (): CollectionReference<Match> =>\n  collection(getDb(), 'matches').withConverter(matchConverter)\n\nexport const invitesCollection = (): CollectionReference<Invite> =>\n  collection(getDb(), 'invites').withConverter(inviteConverter)\n\n// ============ SUBCOLLECTIONS ============\n\nexport const betsCollection = (matchId: string): CollectionReference<Bet> =>\n  collection(getDb(), `matches/${matchId}/bets`).withConverter(betConverter)\n\nexport const participantsCollection = (matchId: string): CollectionReference<Participant> =>\n  collection(getDb(), `matches/${matchId}/participants`).withConverter(participantConverter)\n\nexport const scoresCollection = (matchId: string): CollectionReference<Score> =>\n  collection(getDb(), `matches/${matchId}/scores`).withConverter(scoreConverter)\n\nexport const ledgerCollection = (matchId: string): CollectionReference<LedgerEntry> =>\n  collection(getDb(), `matches/${matchId}/ledger`).withConverter(ledgerConverter)\n\nexport const auditCollection = (matchId: string): CollectionReference<AuditEntry> =>\n  collection(getDb(), `matches/${matchId}/audit`).withConverter(auditConverter)\n\n// ============ DOCUMENT REFERENCES ============\n\nexport const userDoc = (userId: string): DocumentReference<User> =>\n  doc(collection(getDb(), 'users'), userId).withConverter(userConverter) as DocumentReference<User>\n\nexport const matchDoc = (matchId: string): DocumentReference<Match> =>\n  doc(collection(getDb(), 'matches'), matchId).withConverter(matchConverter) as DocumentReference<Match>\n\nexport const betDoc = (matchId: string, betId: string): DocumentReference<Bet> =>\n  doc(collection(getDb(), `matches/${matchId}/bets`), betId).withConverter(betConverter) as DocumentReference<Bet>\n\nexport const participantDoc = (\n  matchId: string,\n  participantId: string,\n): DocumentReference<Participant> =>\n  doc(\n    collection(getDb(), `matches/${matchId}/participants`),\n    participantId,\n  ).withConverter(participantConverter) as DocumentReference<Participant>\n\nexport const scoreDoc = (matchId: string, scoreId: string): DocumentReference<Score> =>\n  doc(collection(getDb(), `matches/${matchId}/scores`), scoreId).withConverter(\n    scoreConverter,\n  ) as DocumentReference<Score>\n\nexport const ledgerEntryDoc = (\n  matchId: string,\n  entryId: string,\n): DocumentReference<LedgerEntry> =>\n  doc(collection(getDb(), `matches/${matchId}/ledger`), entryId).withConverter(\n    ledgerConverter,\n  ) as DocumentReference<LedgerEntry>\n\nexport const auditEntryDoc = (\n  matchId: string,\n  auditId: string,\n): DocumentReference<AuditEntry> =>\n  doc(collection(getDb(), `matches/${matchId}/audit`), auditId).withConverter(\n    auditConverter,\n  ) as DocumentReference<AuditEntry>\n\nexport const inviteDoc = (inviteId: string): DocumentReference<Invite> =>\n  doc(collection(getDb(), 'invites'), inviteId).withConverter(\n    inviteConverter,\n  ) as DocumentReference<Invite>\n","'use client'\n\nimport { useEffect } from 'react'\nimport { useRouter } from 'next/navigation'\nimport { useAuth } from '@/hooks/useAuth'\nimport { Screen } from '@/components/layout'\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode\n}\n\nexport function ProtectedRoute({ children }: ProtectedRouteProps) {\n  const { user, loading } = useAuth()\n  const router = useRouter()\n\n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/login')\n    }\n  }, [user, loading, router])\n\n  if (loading) {\n    return (\n      <Screen className=\"flex items-center justify-center\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin text-4xl mb-4\">⛳</div>\n          <p className=\"text-gray-500\">Loading...</p>\n        </div>\n      </Screen>\n    )\n  }\n\n  if (!user) {\n    return null\n  }\n\n  return <>{children}</>\n}\n","import { getDoc, setDoc, updateDoc, query, where, getDocs } from 'firebase/firestore'\nimport { Match, MatchStatus } from '@/types'\nimport { matchDoc, matchesCollection } from './collections'\n\n// ============ READ ============\n\n/**\n * Fetch match document by ID\n */\nexport async function getMatch(matchId: string): Promise<Match | null> {\n  try {\n    const snapshot = await getDoc(matchDoc(matchId))\n    return snapshot.exists() ? snapshot.data() : null\n  } catch (error) {\n    console.error('Error fetching match:', error)\n    throw error\n  }\n}\n\n/**\n * Get all matches for a user (filters by participantIds array)\n * @param userId The user ID to query\n * @param statusFilter Optional status filter (pending, active, completed)\n */\nexport async function getUserMatches(\n  userId: string,\n  statusFilter?: MatchStatus,\n): Promise<Match[]> {\n  try {\n    const q = query(\n      matchesCollection(),\n      where('participantIds', 'array-contains', userId),\n    )\n\n    const snapshot = await getDocs(q)\n    let matches = snapshot.docs.map((doc) => doc.data())\n\n    if (statusFilter) {\n      matches = matches.filter((m) => m.status === statusFilter)\n    }\n\n    // Sort by teeTime descending (most recent first)\n    return matches.sort((a, b) => b.teeTime.getTime() - a.teeTime.getTime())\n  } catch (error) {\n    console.error('Error fetching user matches:', error)\n    throw error\n  }\n}\n\n/**\n * Get all matches created by a user\n */\nexport async function getCreatedMatches(userId: string): Promise<Match[]> {\n  try {\n    const q = query(matchesCollection(), where('createdBy', '==', userId))\n    const snapshot = await getDocs(q)\n    const matches = snapshot.docs.map((doc) => doc.data())\n    return matches.sort((a, b) => b.teeTime.getTime() - a.teeTime.getTime())\n  } catch (error) {\n    console.error('Error fetching created matches:', error)\n    throw error\n  }\n}\n\n// ============ CREATE ============\n\n/**\n * Create new match (called by match creator)\n */\nexport async function createMatch(\n  userId: string,\n  data: {\n    courseName: string\n    teeTime: Date\n    courseId?: string\n    holes?: 9 | 18\n  },\n): Promise<Match> {\n  const now = new Date()\n  const matchId = `match_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n\n  const match: Match = {\n    id: matchId,\n    courseName: data.courseName,\n    courseId: data.courseId || null,\n    teeTime: data.teeTime,\n    holes: data.holes || 18,\n    status: 'pending' as MatchStatus,\n    currentHole: null,\n    createdBy: userId,\n    scorerId: userId,\n    participantIds: [userId],\n    createdAt: now,\n    updatedAt: now,\n    startedAt: null,\n    completedAt: null,\n    version: 1,\n  }\n\n  try {\n    await setDoc(matchDoc(matchId), match)\n    return match\n  } catch (error) {\n    console.error('Error creating match:', error)\n    throw error\n  }\n}\n\n// ============ UPDATE ============\n\n/**\n * Update match status (pending → active → completed)\n */\nexport async function updateMatchStatus(\n  matchId: string,\n  status: MatchStatus,\n): Promise<void> {\n  try {\n    const updates: Record<string, unknown> = {\n      status,\n      updatedAt: new Date(),\n    }\n\n    if (status === 'active') {\n      updates.startedAt = new Date()\n    } else if (status === 'completed') {\n      updates.completedAt = new Date()\n    }\n\n    await updateDoc(matchDoc(matchId), updates)\n  } catch (error) {\n    console.error('Error updating match status:', error)\n    throw error\n  }\n}\n\n/**\n * Add participant to match (updates participantIds array)\n */\nexport async function addParticipantToMatch(\n  matchId: string,\n  userId: string,\n): Promise<void> {\n  try {\n    const match = await getMatch(matchId)\n    if (!match) {\n      throw new Error('Match not found')\n    }\n\n    // Avoid duplicates\n    if (match.participantIds.includes(userId)) {\n      return\n    }\n\n    await updateDoc(matchDoc(matchId), {\n      participantIds: [...match.participantIds, userId],\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error adding participant to match:', error)\n    throw error\n  }\n}\n\n/**\n * Remove participant from match (only if pending status)\n */\nexport async function removeParticipantFromMatch(\n  matchId: string,\n  userId: string,\n): Promise<void> {\n  try {\n    const match = await getMatch(matchId)\n    if (!match) {\n      throw new Error('Match not found')\n    }\n\n    if (match.status !== 'pending') {\n      throw new Error('Cannot remove participants from active or completed matches')\n    }\n\n    await updateDoc(matchDoc(matchId), {\n      participantIds: match.participantIds.filter((id) => id !== userId),\n      updatedAt: new Date(),\n    })\n  } catch (error) {\n    console.error('Error removing participant from match:', error)\n    throw error\n  }\n}\n","'use client'\n\nimport { useEffect, useState } from 'react'\nimport { onSnapshot } from 'firebase/firestore'\nimport { Match, Participant } from '@/types'\nimport { matchDoc, participantsCollection } from '@/lib/firestore/collections'\nimport { getMatch } from '@/lib/firestore/matches'\n\ninterface UseMatchReturn {\n  match: Match | null\n  participants: Participant[]\n  loading: boolean\n  error: Error | null\n}\n\n/**\n * Hook to fetch match data with real-time updates\n * Automatically subscribes to match document and participants subcollection\n *\n * @param matchId Match ID to subscribe to\n * @returns Match, participants, loading state, and error\n */\nexport function useMatch(matchId: string | null): UseMatchReturn {\n  const [match, setMatch] = useState<Match | null>(null)\n  const [participants, setParticipants] = useState<Participant[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    if (!matchId) {\n      return\n    }\n\n    let unsubscribeMatch: (() => void) | null = null\n    let unsubscribeParticipants: (() => void) | null = null\n\n    const setupSubscriptions = async () => {\n      try {\n        // Initial fetch to ensure data exists\n        const matchData = await getMatch(matchId)\n        if (!matchData) {\n          setError(new Error('Match not found'))\n          setLoading(false)\n          return\n        }\n\n        // Subscribe to match document\n        unsubscribeMatch = onSnapshot(matchDoc(matchId), (snapshot) => {\n          if (snapshot.exists()) {\n            setMatch(snapshot.data())\n            setError(null)\n          } else {\n            setError(new Error('Match was deleted'))\n          }\n        })\n\n        // Subscribe to participants subcollection\n        unsubscribeParticipants = onSnapshot(\n          participantsCollection(matchId),\n          (snapshot) => {\n            const participantsData = snapshot.docs.map((doc) => doc.data())\n            setParticipants(participantsData)\n            setLoading(false)\n          },\n          (err) => {\n            console.error('Error subscribing to participants:', err)\n            setError(err instanceof Error ? err : new Error('Unknown error'))\n            setLoading(false)\n          },\n        )\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error('Unknown error')\n        setError(error)\n        setLoading(false)\n      }\n    }\n\n    setupSubscriptions()\n\n    return () => {\n      unsubscribeMatch?.()\n      unsubscribeParticipants?.()\n    }\n  }, [matchId])\n\n  return {\n    match,\n    participants,\n    loading,\n    error,\n  }\n}\n"],"names":[],"mappings":"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"}